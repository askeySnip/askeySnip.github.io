---
layout: post
title: codeforces \#716 div2
categories: [competitive programming, algorithm]
description: solutions
keywords: codeforces, competitive programming
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# codeforces \#716 div2 é¢˜è§£

## A.Perfectly Imperfect Array

é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œé—®å…¶æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå­æ•°ç»„ï¼Œä½¿å…¶å­æ•°ç»„ä¸­æ‰€æœ‰æ•°çš„ä¹˜ç§¯ä¸æ˜¯å¹³æ–¹æ•°ã€‚ï¼ˆå­æ•°ç»„æ˜¯é€šè¿‡åˆ æŽ‰åŽŸæ•°ç»„ä¸­çš„ä¸€äº›å…ƒç´ å¾—åˆ°çš„ï¼Œä¹Ÿå¯èƒ½ä¸åˆ é™¤ï¼‰ã€‚

é¢˜è§£ï¼šåªéœ€åˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ•°ä¸æ˜¯å¹³æ–¹æ•°å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š

```c++
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    cin >> n;
    REP(i, 0, n) { cin >> a[i]; }
    bool f = false;
    REP(i, 0, n) {
      int s = sqrt(a[i] * 1.0);
      if (s * s != a[i]) f = true;
    }
    if (f)
      printf("YES\n");
    else
      printf("NO\n");
  }
  return 0;
}
```

-------

## B. AND 0, Sum Big

é¢˜ç›®ï¼šç»™å®šnå’Œkï¼Œæ‰¾åˆ°æ»¡è¶³å¦‚ä¸‹æ¡ä»¶çš„é•¿åº¦ä¸ºnçš„æ•°ç»„ï¼š
1. æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„å¤§å°éƒ½åœ¨[0, $2^k-1$]
2. å¯¹æ‰€æœ‰å…ƒç´ è¿›è¡Œ&æ“ä½œåŽï¼Œç»“æžœä¸º0
3. æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œå°½å¯èƒ½çš„å¤§

é—®ï¼šæœ‰å¤šå°‘è¿™æ ·çš„æ•°ç»„ï¼Ÿ

é¢˜è§£ï¼šæ¡ä»¶1å¯ä»¥çŸ¥é“ï¼Œæ•°ç»„ä¸­å…ƒç´ çš„äºŒè¿›åˆ¶è¡¨ç¤ºæœ‰kä½ï¼›æ¡ä»¶2å¯çŸ¥ï¼Œkä½ä¸­è‡³å°‘ä¸€ä¸ªæ•°åœ¨è¯¥ä½ç½®ä¸Šä¸º0ï¼›æ¡ä»¶3å¯çŸ¥ï¼Œkä½ä¸­åªæœ‰ä¸€ä¸ªæ•°åœ¨è¯¥ä½ç½®ä¸Šä¸º0ï¼Œå…¶ä½™æ•°è¯¥ä½ç½®ä¸º1. æ‰€ä»¥ï¼Œkä¸ªä½ç½®ï¼Œæ¯ä¸ªä½ç½®å¯é€‰çš„æœ‰nä¸ªï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯$k^n$ã€‚
ä»£ç å¦‚ä¸‹ï¼š
```c++
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int t;
  cin >> t;

  while (t--) {
    int n, k;
    cin >> n >> k;
    mod_int ans = 1;
    REP(i, 0, k) ans = ans * n;
    cout << ans.val << "\n";
  }
  return 0;
}
```
-----

## C. Product 1 Modulo N

é¢˜ç›®ï¼šGiven an integer ð‘›, find the longest subsequence of [1,2,â€¦,ð‘›âˆ’1] whose product is 1 modulo ð‘›.($2â‰¤ð‘›â‰¤10^5$).
A sequence ð‘ is a subsequence of an array ð‘Ž if ð‘ can be obtained from ð‘Ž by deleting some (possibly all) elements. The product of an empty subsequence is equal to 1.

é¢˜è§£ï¼šæˆ‘ä»¬å¯ä»¥å‡è®¾ä¹˜ç§¯ä¸ºpï¼Œé‚£ä¹ˆå°±æœ‰ $p \space mod \space n ==1$,è¿›è€Œå¯ä»¥æŽ¨å‡º$gcd(p \space mod \space n, n) = gcd(p, n) == 1$,å› æ­¤æ¯ä¸€ä¸ªå…ƒç´ éƒ½åº”è¯¥ä¸Žnæ˜¯äº’è´¨çš„ï¼ˆcoprimeï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆèŽ·å–åˆ°æ‰€æœ‰ä¸Žnäº’è´¨çš„æ•°ï¼Œå¾—åˆ°pã€‚å¦‚æžœ$p\%n == 1$é‚£ä¹ˆæ‰€æœ‰çš„è¿™äº›æ•°éƒ½å¯ä»¥ä½¿ç”¨ï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬åº”è¯¥å°†$p\%n$æŽ’é™¤åœ¨å¤–ã€‚

ä»£ç å¦‚ä¸‹ï¼š
```c++
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int n;
  cin >> n;
  vi ans;
  ans.push_back(1);
  ll m = 1;
  REP(i, 2, n) {
    if (__gcd(i, n) == 1) ans.push_back(i), m = m * i % n;
  }
  int s = ans.size();
  if (m != 1) --s;
  cout << s << "\n";
  REP(i, 0, ans.size()) if (i == 0 || ans[i] != m) cout << ans[i] << " ";
  cout << "\n";
  return 0;
}
```

----

## D. Cut and Stick

é¢˜ç›®ï¼šBaby Ehab has a piece of Cut and Stick with an array $a$ of length $n$ written on it. He plans to grab a pair of scissors and do the following to it:
- pick a range $(l, r)$ and cut out every element $a_l, a_l+1, ..., a_r$ in this range;
- stick some of the elements together in the same order they were in the array;
- end up with multiple pieces, where every piece contains some of the elements and every element belongs to some piece.

More formally, he partitions the sequence $a_l, a_l+1, ..., a_r$ into subsequences. He thinks a partitioning is beautiful if for every piece (subsequence) it holds that, if it has length $x$, then no value occurs strictly more than $\lceil\frac{x}{2}\rceil$ times in it.

He didn't pick a range yet, so he's wondering: for ð‘ž ranges $(l, r)$, what is the minimum number of pieces he needs to partition the elements $a_l, a_l+1, ..., a_r$ into so that the partitioning is beautiful.

A sequence ð‘ is a subsequence of an array ð‘Ž if ð‘ can be obtained from ð‘Ž by deleting some (possibly zero) elements. Note that it does not have to be contiguous.

For each query, print the minimum number of subsequences you need to partition this range into so that the partitioning is beautiful.
æ•°æ®èŒƒå›´ï¼š $1 \le n, q \le 3â‹…10^5, 1 \le a_i \le n, 1 \le l \le r \le n$

å¤§æ¦‚çš„æ„æ€å°±æ˜¯ç»™å®šæ•°ç»„açš„ä¸€æ®µï¼Œå¯¹è¿™ä¸€éƒ¨åˆ†è¿›è¡Œsubsequenceçš„æ“ä½œï¼Œä½¿å¾—å¾—åˆ°çš„æ¯ä¸€æ®µï¼ˆè®¾é•¿åº¦ä¸ºxï¼‰ä¸­éƒ½æ²¡æœ‰ä¸€ä¸ªæ•°å‡ºçŽ°çš„æ¬¡æ•°å¤§äºŽ$\lceil\frac{x}{2}\rceil$ã€‚æ±‚æœ€å°‘åˆ†æˆå¤šå°‘æ®µã€‚

é¢˜è§£ï¼šå‡è®¾è¿™ä¸€æ®µä¸­å‡ºçŽ°æœ€å¤šæ¬¡çš„æ•°å‡ºçŽ°çš„æ¬¡æ•°ä¸ºfï¼Œåˆ™æœ‰ä¸¤ç§æƒ…å†µï¼š
1. $f <=\lceil\frac{x}{2}\rceil$ï¼Œé‚£ä¹ˆç»“æžœå°±æ˜¯1.
2. $f >\lceil\frac{x}{2}\rceil$. è®¾ $r-l=m$, ä¸”è®°æ­¤æ—¶å‡ºçŽ°æ¬¡æ•°æœ€å¤šçš„æ•°ä¸ºvï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†$m - f$ä¸ªéžvçš„æ•°ä¸Ž$m-f+1$ä¸ªvç»„åˆåœ¨ä¸€èµ·ï¼Œå…¶ä½™çš„væ¯ä¸ªvå•ç‹¬æ”¾ç½®ã€‚åˆ™ç­”æ¡ˆä¸º$1 + f - (m - f + 1) = 2 * f - m$.

ä¸ºäº†å¿«é€Ÿæ±‚å‡ºæŸä¸ªæ•°åœ¨æŸä¸ªåŒºé—´å‡ºçŽ°çš„æ¬¡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ•°ç»„æ¥è®°å½•è¯¥æ•°å­—åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼Œç„¶åŽä½¿ç”¨upper_boundå’Œlower_boundåœ¨$log(n)$çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚è§£å‡ºæ¥ã€‚

ä¸ºäº†å¿«é€Ÿç¡®å®šè¿™ä¸ªæ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘æ¥è¿›è¡Œæ±‚è§£ã€‚æˆ–è€…ä½¿ç”¨éšæœºé€‰å–çš„æ–¹å¼ï¼šå› ä¸ºè¿™ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°å¤§äºŽ1ï¼2ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€‰æ‹©40æ¬¡ï¼Œåˆ™40æ¬¡éƒ½æ²¡é€‰ä¸­çš„æ¦‚çŽ‡ä¸º$\frac{1}{2^{40}}$,æ²¡é€‰ä¸­çš„æ¦‚çŽ‡éžå¸¸å°ã€‚

çº¿æ®µæ ‘ä»£ç ï¼š
```c++
// struct
const int N = 300010;
// data
vi v[N];
int a[N], tree[4 * N];

int cnt(int l, int r, int x) {
  return upper_bound(all(v[x]), r) - lower_bound(all(v[x]), l);
}

void build(int p, int l, int r) {
  if (l == r) {
    tree[p] = a[l];
    return;
  }
  int mid = (l + r) / 2;
  build(p * 2, l, mid);
  build(p * 2 + 1, mid + 1, r);
  tree[p] = cnt(l, r, tree[p * 2]) > cnt(l, r, tree[p * 2 + 1])
                ? tree[p * 2]
                : tree[p * 2 + 1];
}

int query(int p, int st, int en, int l, int r) {
  if (st > r || en < l || l > r) return 0;
  if (st >= l && en <= r) return cnt(l, r, tree[p]);
  int mid = (st + en) / 2;
  return max(query(p * 2, st, mid, l, r), query(p * 2 + 1, mid + 1, en, l,
  r));
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int n, q;
  cin >> n >> q;
  REP(i, 1, n + 1) cin >> a[i], v[a[i]].push_back(i);
  build(1, 1, n);
  int l, r;
  REP(i, 0, q) {
    cin >> l >> r;
    cout << max(1, 2 * query(1, 1, n, l, r) - (r - l + 1)) << "\n";
  }
  return 0;
}

```

éšæœºæ–¹æ³•ä»£ç ï¼š
```c++
const int N = 300010;
vi v[N];
int a[N];

int cnt(int l, int r, int x) {
  return upper_bound(all(v[x]), r) - lower_bound(all(v[x]), l);
}

int main() {
  int n, q;
  gii(n, q);
  REP(i, 1, n + 1) cin >> a[i], v[a[i]].push_back(i);
  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  int l, r;
  REP(i, 0, q) {
    gii(l, r);
    int ans = 1;
    REP(j, 0, 40) {
      int c = a[uniform_int_distribution<int>(l, r)(rng)];
      int f = upper_bound(all(v[c]), r) - lower_bound(all(v[c]), l);
      ans = max(ans, 2 * f - (r - l + 1));
    }
    cout << ans << "\n";
  }
}

```

## E. Baby Ehab's Hyper Apartment

å¾…æ›´ã€‚